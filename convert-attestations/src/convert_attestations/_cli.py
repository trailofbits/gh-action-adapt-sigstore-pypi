"""The `convert-attestations` entrypoint."""

import argparse
import logging
import os
from json import JSONDecodeError
from pathlib import Path
from tempfile import mkdtemp
from typing import NoReturn

from pypi_attestations import Attestation, AttestationError
from sigstore.models import Bundle

logging.basicConfig(format="%(message)s", datefmt="[%X]", handlers=[logging.StreamHandler()])
_logger = logging.getLogger(__name__)
_logger.setLevel(logging.INFO)


def _die(message: str) -> NoReturn:
    """Handle errors and terminate the program with an error code."""
    _logger.error(message)
    raise SystemExit(1)


def _convert_bundle(filename: Path, bundle_txt: str) -> tuple[str, Attestation]:
    try:
        bundle = Bundle.from_json(bundle_txt)
        attestation = Attestation.from_bundle(bundle)
    except JSONDecodeError as e:
        _die(f"Error while parsing the bundle: {e}")
    except AttestationError as e:
        _die(f"Error while converting the bundle to a PyPI attestation: {e}")

    statement = attestation.statement
    if "subject" not in statement:
        _die(
            f"Unsupported attestation in file '{filename}', expected 'subject' field present in "
            "the in-toto statement"
        )
    elif len(statement["subject"]) != 1:
        _die(
            f"Unsupported attestation in file '{filename}', expected only one subject in the "
            "in-toto statement"
        )
    elif "name" not in statement["subject"][0]:
        _die(
            f"Unsupported attestation in file '{filename}', expected 'name' field present in the "
            "in-toto subject"
        )

    subject = statement["subject"][0]["name"]
    output_name = subject + ".slsa.attestation"
    return output_name, attestation


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Convert attestations to the format accepted by PyPI",
    )

    parser.add_argument(
        "attestation_files", nargs="+", type=Path, help="Attestation files to convert"
    )
    parser.add_argument("--output-dir", type=Path, help="Attestation files to convert")

    args = parser.parse_args()

    jsonl_files = set()

    for f in args.attestation_files:
        if not f.exists():
            _die(f"Specified file does not exist: {f}")
        elif f.suffix == ".jsonl":
            jsonl_files.add(f)
        else:
            _die(f"File {f} not supported. Only jsonl files are currently supported.")

    # The keys are the filenames of the output PyPI attestations.
    # For SLSA provenance attestations generated by GitHub (of which multiple can be inside a
    # .jsonl file), we output each attestation as a separate file.
    # Each output file will be name using the name of the subject with '.slsa.attestation' appended
    # to it. E.g: An attestation for `mypkg-1.0.tar.gz` will be saved to
    # `mypkg-1.0.tar.gz.slsa.attestation`.
    attestations: dict[str, Attestation] = {}

    for f in jsonl_files:
        with f.open() as contents:
            for line in contents:
                filename, attestation = _convert_bundle(f, line)
                attestations[filename] = attestation

    output_dir = Path(mkdtemp()) if args.output_dir is None else Path(args.output_dir)
    for filename, attestation in attestations.items():
        output_path = output_dir / filename
        output_path.write_text(attestation.model_dump_json(), encoding="utf-8")

    # When running on GHA, set the outputs
    github_env_file = os.getenv("GITHUB_ENV")
    if github_env_file:
        with Path(github_env_file).open("a") as f:
            f.write(f"output-dir={output_dir}")

    _logger.info(
        "OK: %s attestations converted and written to %s", len(attestations), output_dir.absolute()
    )
