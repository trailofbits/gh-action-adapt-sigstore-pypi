# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "pypi-attestations==0.0.19",
# ]
# ///

import argparse
import os
import logging
from pathlib import Path
from typing import NoReturn
from pypi_attestations import Attestation
from sigstore.models import Bundle
from tempfile import mkdtemp

logging.basicConfig(
    format="%(message)s", datefmt="[%X]", handlers=[logging.StreamHandler()]
)
_logger = logging.getLogger(__name__)
_logger.setLevel(logging.INFO)


def _die(message: str) -> NoReturn:
    """Handle errors and terminate the program with an error code."""
    _logger.error(message)
    raise SystemExit(1)


def _convert_bundle(filename: Path, bundle_txt: str) -> tuple[str, Attestation]:
    try:
        bundle = Bundle.from_json(bundle_txt)
        attestation = Attestation.from_bundle(bundle)
    except Exception as e:
        _die(f"Error while parsing the bundle: {e}")
    statement = attestation.statement
    if "subject" not in statement:
        _die(
            f"Unsupported attestation in file '{filename}', expected 'subject' field present in the in-toto statement"
        )
    elif len(statement["subject"]) != 1:
        _die(
            f"Unsupported attestation in file '{filename}', expected only one subject in the in-toto statement"
        )
    elif "name" not in statement["subject"][0]:
        _die(
            f"Unsupported attestation in file '{filename}', expected 'name' field present in the in-toto subject"
        )

    subject = statement["subject"][0]["name"]
    output_name = subject + ".slsa.attestation"
    return output_name, attestation


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Convert attestations to the format accepted by PyPI",
    )

    parser.add_argument(
        "attestation_files", nargs="+", type=Path, help="Attestation files to convert"
    )

    args = parser.parse_args()

    jsonl_files = set()

    for f in args.attestation_files:
        if not f.exists():
            _die(f"Specified file does not exist: {f}")
        elif f.suffix == ".jsonl":
            jsonl_files.add(f)
        else:
            _die(f"File {f} not supported. Only jsonl files are currently supported.")

    # The keys are the filenames of the output PyPI attestations.
    # For SLSA provenance attestations generated by GitHub (of which multiple can be
    # inside a single .jsonl file), we output each attestation as a separate file
    # Each output file will be name using the name of the subject with '.slsa.attestation' appended to it.
    # E.g: An attestation for `mypkg-1.0.tar.gz` will be saved to `mypkg-1.0.tar.gz.slsa.attestation`.
    attestations: dict[str, Attestation] = dict()

    for f in jsonl_files:
        with f.open() as contents:
            for line in contents:
                filename, attestation = _convert_bundle(f, line)
                attestations[filename] = attestation

    output_dir = Path(mkdtemp())
    for filename, attestation in attestations.items():
        output_path = output_dir / filename
        output_path.write_text(attestation.model_dump_json(), encoding="utf-8")

    # When running on GHA, set the outputs
    github_env_file = os.getenv("GITHUB_ENV")
    if github_env_file:
        with open(github_env_file, "a") as f:
            f.write(f"output-dir={output_dir}")

    _logger.info(
        f"OK: {len(attestations)} attestations converted and written to {output_dir}"
    )


if __name__ == "__main__":
    main()
